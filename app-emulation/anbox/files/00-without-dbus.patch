diff --git a/CMakeLists.txt b/CMakeLists.txt
index 8d350a4..f32c71d 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -65,10 +65,10 @@ find_package(Protobuf REQUIRED)
 
 pkg_check_modules(SDL2 sdl2 REQUIRED)
 pkg_check_modules(SDL2_IMAGE SDL2_image REQUIRED)
-pkg_check_modules(DBUS dbus-1 REQUIRED)
+# pkg_check_modules(DBUS dbus-1 REQUIRED)
 pkg_check_modules(LXC lxc REQUIRED)
 pkg_check_modules(PROPERTIES_CPP properties-cpp REQUIRED)
-pkg_check_modules(LIBSYSTEMD libsystemd REQUIRED)
+# pkg_check_modules(LIBSYSTEMD libsystemd REQUIRED)
 
 message(STATUS "LXC version: ${LXC_VERSION}")
 if (${LXC_VERSION} VERSION_LESS 3.0)
@@ -108,7 +108,7 @@ IF(CMAKE_BUILD_TYPE MATCHES [cC][oO][vV][eE][rR][aA][gG][eE])
   SET(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -ftest-coverage -fprofile-arcs" )
 ENDIF(CMAKE_BUILD_TYPE MATCHES [cC][oO][vV][eE][rR][aA][gG][eE])
 
-find_package(GMock)
+# find_package(GMock)
 
 set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++14 -fPIC")
 
@@ -128,7 +128,8 @@ configure_file(${CMAKE_CURRENT_SOURCE_DIR}/src/anbox/build/config.h.in
 
 add_subdirectory(external)
 add_subdirectory(src)
-add_subdirectory(tests)
+add_subdirectory(src2)
+# add_subdirectory(tests)
 add_subdirectory(android)
 
 if (NOT "${HOST_CMAKE_C_COMPILER}" STREQUAL "")
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 7622d72..99aca7e 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -87,16 +87,16 @@ set(SOURCES
 
     anbox/cmds/container_manager.cpp
     anbox/cmds/container_manager.h
-    anbox/cmds/launch.cpp
-    anbox/cmds/launch.h
-    anbox/cmds/session_manager.cpp
-    anbox/cmds/session_manager.h
+    # anbox/cmds/launch.cpp
+    # anbox/cmds/launch.h
+    # anbox/cmds/session_manager.cpp
+    # anbox/cmds/session_manager.h
     anbox/cmds/system_info.cpp
     anbox/cmds/system_info.h
     anbox/cmds/version.cpp
     anbox/cmds/version.h
-    anbox/cmds/wait_ready.cpp
-    anbox/cmds/wait_ready.h
+    # anbox/cmds/wait_ready.cpp
+    # anbox/cmds/wait_ready.h
     anbox/cmds/check_features.cpp
     anbox/cmds/check_features.h
 
@@ -138,20 +138,19 @@ set(SOURCES
     anbox/container/service.cpp
     anbox/container/service.h
 
-    anbox/dbus/bus.cpp
-    anbox/dbus/bus.h
-    anbox/dbus/codecs.h
-    anbox/dbus/interface.h
-    anbox/dbus/sd_bus_helpers.c
-    anbox/dbus/sd_bus_helpers.h
-    anbox/dbus/sd_bus_helpers.hpp
-    anbox/dbus/skeleton/application_manager.cpp
-    anbox/dbus/skeleton/application_manager.h
-    anbox/dbus/skeleton/service.cpp
-    anbox/dbus/skeleton/service.h
-    anbox/dbus/stub/application_manager.cpp
-    anbox/dbus/stub/application_manager.h
-
+    # anbox/dbus/bus.cpp
+    # anbox/dbus/bus.h
+    # anbox/dbus/codecs.h
+    # anbox/dbus/interface.h
+    # anbox/dbus/sd_bus_helpers.c
+    # anbox/dbus/sd_bus_helpers.h
+    # anbox/dbus/sd_bus_helpers.hpp
+    # anbox/dbus/skeleton/application_manager.cpp
+    # anbox/dbus/skeleton/application_manager.h
+    # anbox/dbus/skeleton/service.cpp
+    # anbox/dbus/skeleton/service.h
+    # anbox/dbus/stub/application_manager.cpp
+    # anbox/dbus/stub/application_manager.h
     anbox/graphics/buffered_io_stream.cpp
     anbox/graphics/buffered_io_stream.h
     anbox/graphics/buffer_queue.cpp
@@ -250,15 +249,15 @@ set(SOURCES
     anbox/platform/base_platform.h
     anbox/platform/null/platform.cpp
     anbox/platform/null/platform.h
-    anbox/platform/sdl/audio_sink.cpp
-    anbox/platform/sdl/audio_sink.h
-    anbox/platform/sdl/keycode_converter.cpp
-    anbox/platform/sdl/keycode_converter.h
-    anbox/platform/sdl/platform.cpp
-    anbox/platform/sdl/platform.h
-    anbox/platform/sdl/sdl_wrapper.h
-    anbox/platform/sdl/window.cpp
-    anbox/platform/sdl/window.h
+    # anbox/platform/sdl/audio_sink.cpp
+    # anbox/platform/sdl/audio_sink.h
+    # anbox/platform/sdl/keycode_converter.cpp
+    # anbox/platform/sdl/keycode_converter.h
+    # anbox/platform/sdl/platform.cpp
+    # anbox/platform/sdl/platform.h
+    # anbox/platform/sdl/sdl_wrapper.h
+    # anbox/platform/sdl/window.cpp
+    # anbox/platform/sdl/window.h
 
     anbox/protobuf/anbox_bridge.proto
     anbox/protobuf/anbox_container.proto
@@ -329,8 +328,8 @@ set(SOURCES
 
     anbox/cli.cpp
     anbox/cli.h
-    anbox/daemon.cpp
-    anbox/daemon.h
+    # anbox/daemon.cpp
+    # anbox/daemon.h
     anbox/defer_action.h
     anbox/do_not_copy_or_move.h
     anbox/logger.cpp
@@ -371,13 +370,13 @@ target_link_libraries(anbox-core
   anbox-protobuf
   xdg)
 
-add_executable(anbox main.cpp ${BACKWARD_ENABLE})
-target_link_libraries(anbox
-    anbox-core)
-add_backward(anbox)
+# add_executable(anbox main.cpp ${BACKWARD_ENABLE})
+# target_link_libraries(anbox
+#     anbox-core)
+# add_backward(anbox)
 
-install(
-  TARGETS anbox
-  RUNTIME DESTINATION bin
-  LIBRARY DESTINATION lib
-  ARCHIVE DESTINATION lib/static)
+# install(
+#   TARGETS anbox
+#   RUNTIME DESTINATION bin
+#   LIBRARY DESTINATION lib
+#   ARCHIVE DESTINATION lib/static)
diff --git a/src/anbox/graphics/program_family.h b/src/anbox/graphics/program_family.h
index 4de720e..de8ea42 100644
--- a/src/anbox/graphics/program_family.h
+++ b/src/anbox/graphics/program_family.h
@@ -19,6 +19,9 @@
 #ifndef ANBOX_GRAPHICS_PROGRAM_FAMILY_H_
 #define ANBOX_GRAPHICS_PROGRAM_FAMILY_H_
 
+#include <string>
+#include <sstream>
+#include <iostream>
 #include <map>
 #include <unordered_map>
 #include <utility>
diff --git a/src2/CMakeLists.txt b/src2/CMakeLists.txt
new file mode 100644
index 0000000..0faccc4
--- /dev/null
+++ b/src2/CMakeLists.txt
@@ -0,0 +1,115 @@
+include_directories(
+  ${Boost_INCLUDE_DIRS}
+  ${MIRCLIENT_INCLUDE_DIRS}
+  ${DBUS_INCLUDE_DIRS}
+  ${SDL2_INCLUDE_DIRS}
+  ${SDL2_IMAGE_INCLUDE_DIRS}
+  ${PROPERTIES_CPP_INCLUDE_DIRS}
+  ${LXC_INCLUDE_DIRS}
+  ${MIRCLIENT_INCLUDE_DIRS}
+  ${LIBSYSTEMD_INCLUDE_DIRS}
+  ${CMAKE_CURRENT_BINARY_DIR}
+  ${CMAKE_SOURCE_DIR}
+  ${CMAKE_SOURCE_DIR}/src
+  ${CMAKE_SOURCE_DIR}/src2
+  ${CMAKE_SOURCE_DIR}/external
+  ${CMAKE_SOURCE_DIR}/external/process-cpp-minimal/include
+  ${CMAKE_SOURCE_DIR}/external/android-emugl/shared
+  ${CMAKE_SOURCE_DIR}/external/android-emugl/host/include
+  ${CMAKE_BINARY_DIR}/external/android-emugl/host/include
+  ${CMAKE_SOURCE_DIR}/external/android-emugl/shared/OpenglCodecCommon
+  ${CMAKE_SOURCE_DIR}/external/android-emugl/host/libs
+  ${CMAKE_SOURCE_DIR}/external/android-emugl/host/include/libOpenglRender
+  ${CMAKE_SOURCE_DIR}/external/android-emugl/host/libs/GLESv1_dec
+  ${CMAKE_BINARY_DIR}/external/android-emugl/host/libs/GLESv1_dec
+  ${CMAKE_SOURCE_DIR}/external/android-emugl/host/libs/GLESv2_dec
+  ${CMAKE_BINARY_DIR}/external/android-emugl/host/libs/GLESv2_dec
+  ${CMAKE_SOURCE_DIR}/external/android-emugl/host/libs/renderControl_dec
+  ${CMAKE_BINARY_DIR}/external/android-emugl/host/libs/renderControl_dec
+  ${CMAKE_SOURCE_DIR}/external/glm
+  ${CMAKE_SOURCE_DIR}/external/cpu_features/include
+)
+
+# if(POLICY CMP0079)
+#   cmake_policy(SET CMP0079 NEW)
+# endif()
+
+# protobuf_generate_cpp(
+#     GENERATED_PROTOBUF_RPC_SRCS GENERATED_PROTOBUF_RPC_HDRS
+#     ../src/anbox/protobuf/anbox_rpc.proto)
+
+# protobuf_generate_cpp(
+#     GENERATED_PROTOBUF_BRIDGE_SRCS GENERATED_PROTOBUF_BRIDGE_HDRS
+#     ../src/anbox/protobuf/anbox_bridge.proto)
+
+# protobuf_generate_cpp(
+#     GENERATED_PROTOBUF_CONTAINER_SRCS GENERATED_PROTOBUF_CONTAINER_HDRS
+#     ../src/anbox/protobuf/anbox_container.proto)
+
+
+# add_library(anbox-protobuf
+#     STATIC
+#     ${GENERATED_PROTOBUF_BRIDGE_SRCS}
+#     ${GENERATED_PROTOBUF_BRIDGE_HDRS}
+#     ${GENERATED_PROTOBUF_RPC_SRCS}
+#     ${GENERATED_PROTOBUF_RPC_HDRS}
+#     ${GENERATED_PROTOBUF_CONTAINER_SRCS}
+#     ${GENERATED_PROTOBUF_CONTAINER_HDRS}
+#     ../src/anbox/protobuf/anbox_rpc.proto
+#     ../src/anbox/protobuf/anbox_bridge.proto
+#     ../src/anbox/protobuf/anbox_container.proto
+#     ../src/anbox/protobuf/google_protobuf_guard.cpp)
+# target_link_libraries(anbox-protobuf
+#     ${PROTOBUF_LITE_LIBRARIES})
+
+set(SOURCES
+    )
+
+# add_library(anbox-core STATIC ${SOURCES})
+# target_link_libraries(anbox-core
+#   ${Boost_LDFLAGS}
+#   ${Boost_LIBRARIES}
+#   ${SDL2_LDFLAGS}
+#   ${SDL2_LIBRARIES}
+#   ${SDL2_IMAGE_LDFLAGS}
+#   ${SDL2_IMAGE_LIBRARIES}
+#   ${LXC_LDFLAGS}
+#   ${LXC_LIBRARIES}
+#   ${MIRCLIENT_LDFLAGS}
+#   ${MIRCLIENT_LIBRARIES}
+#   ${LIBSYSTEMD_LDFLAGS}
+#   ${LIBSYSTEMD_LIBRARIES}
+#   cpu_features
+#   pthread
+#   process-cpp
+#   emugl_common
+#   GLESv1_dec
+#   GLESv2_dec
+#   renderControl_dec
+#   OpenGLESDispatch
+#   OpenglCodecCommon
+#   anbox-protobuf
+#   xdg)
+
+add_executable(anbox-session session.cc ${BACKWARD_ENABLE})
+target_link_libraries(anbox-session
+    anbox-core)
+add_backward(anbox-session)
+
+install(
+  TARGETS anbox-session
+  RUNTIME DESTINATION bin
+  LIBRARY DESTINATION lib
+  ARCHIVE DESTINATION lib/static)
+
+
+add_executable(anbox-container container.cc ${BACKWARD_ENABLE})
+target_link_libraries(anbox-container
+    anbox-core)
+add_backward(anbox-container)
+
+install(
+  TARGETS anbox-container
+  RUNTIME DESTINATION bin
+  LIBRARY DESTINATION lib
+  ARCHIVE DESTINATION lib/static)
diff --git a/src2/container.cc b/src2/container.cc
new file mode 100644
index 0000000..77ed014
--- /dev/null
+++ b/src2/container.cc
@@ -0,0 +1,15 @@
+#include "anbox/utils.h"
+
+#include "anbox/cmds/container_manager.h"
+
+using namespace anbox;
+
+int main(int argc, char** argv) {
+  auto haha = std::make_shared<cmds::ContainerManager>();
+
+  haha->run({
+    std::cin, std::cout, anbox::utils::collect_arguments(argc, argv)    
+  });
+
+  return 0;
+}
\ No newline at end of file
diff --git a/src2/session.cc b/src2/session.cc
new file mode 100644
index 0000000..5c07aa9
--- /dev/null
+++ b/src2/session.cc
@@ -0,0 +1,320 @@
+/*
+ * Copyright (C) 2016 Simon Fels <morphis@gravedo.de>
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 3, as published
+ * by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranties of
+ * MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
+ * PURPOSE.  See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wswitch-default"
+#include <boost/filesystem.hpp>
+
+#include "core/posix/signal.h"
+
+#include "anbox/utils.h"
+
+#include "anbox/application/launcher_storage.h"
+#include "anbox/application/database.h"
+#include "anbox/audio/server.h"
+#include "anbox/bridge/android_api_stub.h"
+#include "anbox/bridge/platform_api_skeleton.h"
+#include "anbox/bridge/platform_message_processor.h"
+#include "anbox/graphics/gl_renderer_server.h"
+
+#include "anbox/cmds/session_manager.h"
+#include "anbox/common/dispatcher.h"
+#include "anbox/system_configuration.h"
+#include "anbox/container/client.h"
+// #include "anbox/dbus/bus.h"
+// #include "anbox/dbus/skeleton/service.h"
+#include "anbox/input/manager.h"
+#include "anbox/logger.h"
+#include "anbox/network/published_socket_connector.h"
+#include "anbox/qemu/pipe_connection_creator.h"
+#include "anbox/rpc/channel.h"
+#include "anbox/rpc/connection_creator.h"
+#include "anbox/runtime.h"
+#include "anbox/platform/base_platform.h"
+// #include "anbox/wm/multi_window_manager.h"
+#include "anbox/wm/single_window_manager.h"
+#include "anbox/platform/null/platform.h"
+
+#include "external/xdg/xdg.h"
+
+#include <sys/prctl.h>
+
+#pragma GCC diagnostic pop
+
+namespace fs = boost::filesystem;
+
+namespace {
+constexpr const char *default_appmgr_package{"org.anbox.appmgr"};
+constexpr const char *default_appmgr_component{"org.anbox.appmgr.AppViewActivity"};
+const boost::posix_time::milliseconds default_appmgr_startup_delay{50};
+const anbox::graphics::Rect default_single_window_size{0, 0, 1024, 768};
+
+class NullConnectionCreator : public anbox::network::ConnectionCreator<
+                                  boost::asio::local::stream_protocol> {
+ public:
+  void create_connection_for(
+      std::shared_ptr<boost::asio::local::stream_protocol::socket> const
+          &socket) override {
+    WARNING("Not implemented");
+    socket->close();
+  }
+};
+}
+
+void anbox::cmds::SessionManager::launch_appmgr_if_needed(const std::shared_ptr<bridge::AndroidApiStub> &android_api_stub) {
+  if (!single_window_)
+    return;
+
+  android::Intent launch_intent;
+  launch_intent.package = default_appmgr_package;
+  launch_intent.component = default_appmgr_component;
+  // As this will only be executed in single window mode we don't have
+  // to specify and launch bounds.
+  android_api_stub->launch(launch_intent, graphics::Rect::Invalid, wm::Stack::Id::Default);
+}
+
+anbox::cmds::SessionManager::SessionManager()
+    : CommandWithFlagsAndAction{cli::Name{"session-manager"}, cli::Usage{"session-manager"},
+                                cli::Description{"Run the the anbox session manager"}},
+      window_size_(default_single_window_size) {
+  // Just for the purpose to allow QtMir (or unity8) to find this on our
+  // /proc/*/cmdline
+  // for proper confinement etc.
+  flag(cli::make_flag(cli::Name{"desktop_file_hint"},
+                      cli::Description{"Desktop file hint for QtMir/Unity8"},
+                      desktop_file_hint_));
+  flag(cli::make_flag(cli::Name{"single-window"},
+                      cli::Description{"Start in single window mode."},
+                      single_window_));
+  flag(cli::make_flag(cli::Name{"window-size"},
+                      cli::Description{"Size of the window in single window mode, e.g. --window-size=1024,768"},
+                      window_size_));
+  flag(cli::make_flag(cli::Name{"standalone"},
+                      cli::Description{"Prevents the Container Manager from starting the default container (Experimental)"},
+                      standalone_));
+  flag(cli::make_flag(cli::Name{"experimental"},
+                      cli::Description{"Allows users to use experimental features"},
+                      experimental_));
+  flag(cli::make_flag(cli::Name{"use-system-dbus"},
+                      cli::Description{"Use system instead of session DBus"},
+                      use_system_dbus_));
+  flag(cli::make_flag(cli::Name{"software-rendering"},
+                      cli::Description{"Use software rendering instead of hardware accelerated GL rendering"},
+                      use_software_rendering_));
+  flag(cli::make_flag(cli::Name{"no-touch-emulation"},
+                      cli::Description{"Disable touch emulation applied on mouse inputs"},
+                      no_touch_emulation_));
+
+  action([this](const cli::Command::Context &) {
+    auto trap = core::posix::trap_signals_for_process(
+        {core::posix::Signal::sig_term, core::posix::Signal::sig_int});
+    trap->signal_raised().connect([trap](const core::posix::Signal &signal) {
+      INFO("Signal %i received. Good night.", static_cast<int>(signal));
+      trap->stop();
+    });
+
+    if (standalone_ && !experimental_) {
+      ERROR("Experimental features selected, but --experimental flag not set");
+      return EXIT_FAILURE;
+    }
+
+    if (!fs::exists("/dev/binder") || !fs::exists("/dev/ashmem")) {
+      ERROR("Failed to start as either binder or ashmem kernel drivers are not loaded");
+      return EXIT_FAILURE;
+    }
+
+    utils::ensure_paths({
+        SystemConfiguration::instance().socket_dir(),
+        SystemConfiguration::instance().input_device_dir(),
+    });
+
+    auto rt = Runtime::create();
+    auto dispatcher = anbox::common::create_dispatcher_for_runtime(rt);
+
+    if (!standalone_) {
+      container_ = std::make_shared<container::Client>(rt);
+      container_->register_terminate_handler([&]() {
+        WARNING("Lost connection to container manager, terminating.");
+        trap->stop();
+      });
+    }
+
+    auto input_manager = std::make_shared<input::Manager>(rt);
+    auto android_api_stub = std::make_shared<bridge::AndroidApiStub>();
+
+    auto display_frame = graphics::Rect::Invalid;
+    if (single_window_)
+      display_frame = window_size_;
+
+    const auto should_enable_touch_emulation = utils::get_env_value("ANBOX_ENABLE_TOUCH_EMULATION", "true");
+    if (should_enable_touch_emulation == "false" || no_touch_emulation_)
+      no_touch_emulation_ = true;
+
+    platform::Configuration platform_config;
+    platform_config.single_window = single_window_;
+    platform_config.no_touch_emulation = no_touch_emulation_;
+    platform_config.display_frame = display_frame;
+
+    auto platform = std::make_shared<platform::NullPlatform>();
+    // auto platform = platform::create(utils::get_env_value("ANBOX_PLATFORM", "sdl"),
+    //                                  input_manager,
+    //                                  platform_config);
+    if (!platform)
+      return EXIT_FAILURE;
+
+    auto app_db = std::make_shared<application::Database>();
+
+    std::shared_ptr<wm::Manager> window_manager;
+    bool using_single_window = false;
+    if (platform->supports_multi_window() && !single_window_){
+      // window_manager = std::make_shared<wm::MultiWindowManager>(platform, android_api_stub, app_db);
+    }else {
+      window_manager = std::make_shared<wm::SingleWindowManager>(platform, display_frame, app_db);
+      using_single_window = true;
+    }
+
+    const auto should_force_software_rendering = utils::get_env_value("ANBOX_FORCE_SOFTWARE_RENDERING", "false");
+    auto gl_driver = graphics::GLRendererServer::Config::Driver::Host;
+    if (should_force_software_rendering == "true" || use_software_rendering_)
+     gl_driver = graphics::GLRendererServer::Config::Driver::Software;
+
+    graphics::GLRendererServer::Config renderer_config {
+      gl_driver,
+      single_window_
+    };
+    auto gl_server = std::make_shared<graphics::GLRendererServer>(renderer_config, window_manager);
+
+    platform->set_window_manager(window_manager);
+    platform->set_renderer(gl_server->renderer());
+    window_manager->setup();
+
+    auto app_manager = std::static_pointer_cast<application::Manager>(android_api_stub);
+    if (!using_single_window) {
+      // When we're not running single window mode we need to restrict ourself to
+      // only launch applications in freeform mode as otherwise the window tracking
+      // doesn't work.
+      app_manager = std::make_shared<application::RestrictedManager>(
+            android_api_stub, wm::Stack::Id::Freeform);
+    }
+
+    auto audio_server = std::make_shared<audio::Server>(rt, platform);
+
+    const auto socket_path = SystemConfiguration::instance().socket_dir();
+
+    // The qemu pipe is used as a very fast communication channel between guest
+    // and host for things like the GLES emulation/translation, the RIL or ADB.
+    auto qemu_pipe_connector =
+        std::make_shared<network::PublishedSocketConnector>(
+            utils::string_format("%s/qemu_pipe", socket_path), rt,
+            std::make_shared<qemu::PipeConnectionCreator>(gl_server->renderer(), rt));
+
+    boost::asio::deadline_timer appmgr_start_timer(rt->service());
+
+    auto bridge_connector = std::make_shared<network::PublishedSocketConnector>(
+        utils::string_format("%s/anbox_bridge", socket_path), rt,
+        std::make_shared<rpc::ConnectionCreator>(
+            rt, [&](const std::shared_ptr<network::MessageSender> &sender) {
+              auto pending_calls = std::make_shared<rpc::PendingCallCache>();
+              auto rpc_channel =
+                  std::make_shared<rpc::Channel>(pending_calls, sender);
+              // This is safe as long as we only support a single client. If we
+              // support
+              // more than one one day we need proper dispatching to the right
+              // one.
+              android_api_stub->set_rpc_channel(rpc_channel);
+
+              auto server = std::make_shared<bridge::PlatformApiSkeleton>(
+                  pending_calls, platform, window_manager, app_db);
+              server->register_boot_finished_handler([&]() {
+                DEBUG("Android successfully booted");
+                android_api_stub->ready().set(true);
+                appmgr_start_timer.expires_from_now(default_appmgr_startup_delay);
+                appmgr_start_timer.async_wait([&](const boost::system::error_code &err) {
+                  if (err != boost::system::errc::success)
+                    return;
+                  launch_appmgr_if_needed(android_api_stub);
+                });
+              });
+              return std::make_shared<bridge::PlatformMessageProcessor>(
+                  sender, server, pending_calls);
+            }));
+
+    container::Configuration container_configuration;
+
+    // Instruct healthd to fake battery level as it may take it from other connected
+    // devices like mouse or keyboard and will incorrectly show a system popup to
+    // shutdown the Android system because of low battery. This prevents any kind of
+    // input as focus is bound to the system popup exclusively.
+    //
+    // See https://github.com/anbox/anbox/issues/780 for further details.
+    container_configuration.extra_properties.push_back("ro.boot.fake_battery=1");
+
+    if (!standalone_) {
+      container_configuration.bind_mounts = {
+        {qemu_pipe_connector->socket_file(), "/dev/qemu_pipe"},
+        {bridge_connector->socket_file(), "/dev/anbox_bridge"},
+        {audio_server->socket_file(), "/dev/anbox_audio"},
+        {SystemConfiguration::instance().input_device_dir(), "/dev/input"},
+
+      };
+
+      container_configuration.devices = {
+        {"/dev/binder", {0666}},
+        {"/dev/ashmem", {0666}},
+        {"/dev/fuse", {0666}},
+      };
+
+      dispatcher->dispatch([&]() {
+        container_->start(container_configuration);
+      });
+    }
+
+    // auto bus_type = anbox::dbus::Bus::Type::Session;
+    // if (use_system_dbus_)
+    //   bus_type = anbox::dbus::Bus::Type::System;
+    // auto bus = std::make_shared<anbox::dbus::Bus>(bus_type);
+
+    // auto skeleton = anbox::dbus::skeleton::Service::create_for_bus(bus, app_manager);
+
+    // bus->run_async();
+
+    rt->start();
+    trap->run();
+
+    if (!standalone_) {
+      // Stop the container which should close all open connections we have on
+      // our side and should terminate all services.
+      container_->stop();
+    }
+
+    rt->stop();
+
+    return EXIT_SUCCESS;
+  });
+}
+
+using namespace anbox;
+
+int main(int argc, char** argv) {
+  auto haha = std::make_shared<cmds::SessionManager>();
+
+  haha->run({
+    std::cin, std::cout, anbox::utils::collect_arguments(argc, argv)    
+  });
+
+  return 0;
+}
\ No newline at end of file
