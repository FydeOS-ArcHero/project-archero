diff --git a/src/anbox/dbus/bus.cpp b/src/anbox/dbus/bus.cpp
index 92813f9..8416e2e 100644
--- a/src/anbox/dbus/bus.cpp
+++ b/src/anbox/dbus/bus.cpp
@@ -24,10 +24,10 @@ Bus::Bus(Type type) {
   int ret = 0;
   switch (type) {
   case Type::Session:
-    ret = sd_bus_open_user(&bus_);
+    // ret = sd_bus_open_user(&bus_);
     break;
   case Type::System:
-    ret = sd_bus_open_system(&bus_);
+    // ret = sd_bus_open_system(&bus_);
     break;
   default:
     throw std::invalid_argument("Invalid bus type");
@@ -40,15 +40,18 @@ Bus::Bus(Type type) {
 Bus::~Bus() {
   stop();
 
-  if (bus_)
-    sd_bus_unref(bus_);
+  // if (bus_)
+  //   sd_bus_unref(bus_);
 }
 
 bool Bus::has_service_with_name(const std::string &name) {
-  auto r = sd_bus_get_name_creds(bus_,
-                                 name.c_str(),
-                                 0,
-                                 nullptr);
+  DEBUG("%s", name.c_str());
+
+  auto r = 1;
+  // auto r = sd_bus_get_name_creds(bus_,
+  //                                name.c_str(),
+  //                                0,
+  //                                nullptr);
   return r >= 0;
 }
 
@@ -69,13 +72,14 @@ void Bus::stop() {
 
 void Bus::worker_main() {
   while (running_) {
-    auto ret = sd_bus_process(bus_, nullptr);
+    auto ret = 1;
+    // auto ret = sd_bus_process(bus_, nullptr);
     if (ret < 0)
       break;
     if (ret > 0)
       continue;
 
-    ret = sd_bus_wait(bus_, 1000 * 500);
+    // ret = sd_bus_wait(bus_, 1000 * 500);
     if (ret < 0)
       break;
   }
diff --git a/src/anbox/dbus/bus.h b/src/anbox/dbus/bus.h
index fe3eeac..0d13479 100644
--- a/src/anbox/dbus/bus.h
+++ b/src/anbox/dbus/bus.h
@@ -25,7 +25,9 @@
 #include <mutex>
 #include <thread>
 
-#include <systemd/sd-bus.h>
+struct sd_bus{
+
+};
 
 namespace anbox {
 namespace dbus {
diff --git a/src/anbox/dbus/sd_bus_helpers.h b/src/anbox/dbus/sd_bus_helpers.h
index f52d5a2..731bc40 100644
--- a/src/anbox/dbus/sd_bus_helpers.h
+++ b/src/anbox/dbus/sd_bus_helpers.h
@@ -1,121 +1,121 @@
-/*
-* Copyright (C) 2018 OpenBMC
-*
-* Taken from https://github.com/openbmc/sdbusplus/blob/master/sdbusplus/vtable.hpp
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-#ifndef ANBOX_DBUS_SD_BUS_HELPERS_H_
-#define ANBOX_DBUS_SD_BUS_HELPERS_H_
-
-#include <systemd/sd-bus-vtable.h>
-
-namespace anbox {
-namespace dbus {
-namespace sdbus {
-namespace vtable {
-constexpr sd_bus_vtable start(uint64_t flags)
-{
-  sd_bus_vtable v{};
-  v.type = _SD_BUS_VTABLE_START;
-  v.flags = flags;
-  v.x.start = decltype(v.x.start){sizeof(sd_bus_vtable)};
-
-  return v;
-}
-
-constexpr sd_bus_vtable end() {
-  sd_bus_vtable v{};
-  v.type = _SD_BUS_VTABLE_END;
-
-  return v;
-}
-
-constexpr sd_bus_vtable method_o(const char* member, const char* signature,
-                                 const char* result,
-                                 sd_bus_message_handler_t handler, size_t offset,
-                                 uint64_t flags) {
-  sd_bus_vtable v{};
-  v.type = _SD_BUS_VTABLE_METHOD;
-  v.flags = flags;
-  v.x.method = decltype(v.x.method){member, signature, result, handler, offset};
-
-  return v;
-}
-
-constexpr sd_bus_vtable method(const char* member, const char* signature,
-                               const char* result, sd_bus_message_handler_t handler,
-                               uint64_t flags) {
-    return method_o(member, signature, result, handler, 0, flags);
-}
-
-constexpr sd_bus_vtable signal(const char* member, const char* signature, uint64_t flags) {
-  sd_bus_vtable v{};
-  v.type = _SD_BUS_VTABLE_SIGNAL;
-  v.flags = flags;
-  v.x.signal = decltype(v.x.signal){member, signature};
-
-  return v;
-}
-
-constexpr sd_bus_vtable property(const char* member, const char* signature,
-                                 sd_bus_property_get_t get,
-                                 uint64_t flags) {
-  sd_bus_vtable v{};
-  v.type = _SD_BUS_VTABLE_PROPERTY;
-  v.flags = flags;
-  v.x.property = decltype(v.x.property){member, signature, get, nullptr, 0};
-
-  return v;
-}
-
-constexpr sd_bus_vtable property(const char* member, const char* signature,
-                                 sd_bus_property_get_t get,
-                                 sd_bus_property_set_t set,
-                                 uint64_t flags) {
-  sd_bus_vtable v{};
-  v.type = _SD_BUS_VTABLE_WRITABLE_PROPERTY;
-  v.flags = flags;
-  v.x.property = decltype(v.x.property){member, signature, get, set, 0};
-
-  return v;
-}
-
-constexpr sd_bus_vtable property_o(const char* member, const char* signature,
-                                   size_t offset, uint64_t flags) {
-  sd_bus_vtable v{};
-  v.type = _SD_BUS_VTABLE_PROPERTY;
-  v.flags = flags;
-  v.x.property = decltype(v.x.property){member, signature, nullptr, nullptr, offset};
-
-  return v;
-}
-
-constexpr sd_bus_vtable property_o(const char* member, const char* signature,
-                                   sd_bus_property_set_t set, size_t offset,
-                                   uint64_t flags)
-{
-  sd_bus_vtable v{};
-  v.type = _SD_BUS_VTABLE_WRITABLE_PROPERTY;
-  v.flags = flags;
-  v.x.property = decltype(v.x.property){member, signature, nullptr, set, offset};
-
-  return v;
-}
-} // namespace vtable
-} // namespace sd_bus
-} // namespace dbus
-} // namespace anbox
-
-#endif
+// /*
+// * Copyright (C) 2018 OpenBMC
+// *
+// * Taken from https://github.com/openbmc/sdbusplus/blob/master/sdbusplus/vtable.hpp
+// *
+// * Licensed under the Apache License, Version 2.0 (the "License");
+// * you may not use this file except in compliance with the License.
+// * You may obtain a copy of the License at
+// *
+// * http://www.apache.org/licenses/LICENSE-2.0
+// *
+// * Unless required by applicable law or agreed to in writing, software
+// * distributed under the License is distributed on an "AS IS" BASIS,
+// * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// * See the License for the specific language governing permissions and
+// * limitations under the License.
+// */
+
+// #ifndef ANBOX_DBUS_SD_BUS_HELPERS_H_
+// #define ANBOX_DBUS_SD_BUS_HELPERS_H_
+
+// #include <systemd/sd-bus-vtable.h>
+
+// namespace anbox {
+// namespace dbus {
+// namespace sdbus {
+// namespace vtable {
+// constexpr sd_bus_vtable start(uint64_t flags)
+// {
+//   sd_bus_vtable v{};
+//   v.type = _SD_BUS_VTABLE_START;
+//   v.flags = flags;
+//   v.x.start = decltype(v.x.start){sizeof(sd_bus_vtable)};
+
+//   return v;
+// }
+
+// constexpr sd_bus_vtable end() {
+//   sd_bus_vtable v{};
+//   v.type = _SD_BUS_VTABLE_END;
+
+//   return v;
+// }
+
+// constexpr sd_bus_vtable method_o(const char* member, const char* signature,
+//                                  const char* result,
+//                                  sd_bus_message_handler_t handler, size_t offset,
+//                                  uint64_t flags) {
+//   sd_bus_vtable v{};
+//   v.type = _SD_BUS_VTABLE_METHOD;
+//   v.flags = flags;
+//   v.x.method = decltype(v.x.method){member, signature, result, handler, offset};
+
+//   return v;
+// }
+
+// constexpr sd_bus_vtable method(const char* member, const char* signature,
+//                                const char* result, sd_bus_message_handler_t handler,
+//                                uint64_t flags) {
+//     return method_o(member, signature, result, handler, 0, flags);
+// }
+
+// constexpr sd_bus_vtable signal(const char* member, const char* signature, uint64_t flags) {
+//   sd_bus_vtable v{};
+//   v.type = _SD_BUS_VTABLE_SIGNAL;
+//   v.flags = flags;
+//   v.x.signal = decltype(v.x.signal){member, signature};
+
+//   return v;
+// }
+
+// constexpr sd_bus_vtable property(const char* member, const char* signature,
+//                                  sd_bus_property_get_t get,
+//                                  uint64_t flags) {
+//   sd_bus_vtable v{};
+//   v.type = _SD_BUS_VTABLE_PROPERTY;
+//   v.flags = flags;
+//   v.x.property = decltype(v.x.property){member, signature, get, nullptr, 0};
+
+//   return v;
+// }
+
+// constexpr sd_bus_vtable property(const char* member, const char* signature,
+//                                  sd_bus_property_get_t get,
+//                                  sd_bus_property_set_t set,
+//                                  uint64_t flags) {
+//   sd_bus_vtable v{};
+//   v.type = _SD_BUS_VTABLE_WRITABLE_PROPERTY;
+//   v.flags = flags;
+//   v.x.property = decltype(v.x.property){member, signature, get, set, 0};
+
+//   return v;
+// }
+
+// constexpr sd_bus_vtable property_o(const char* member, const char* signature,
+//                                    size_t offset, uint64_t flags) {
+//   sd_bus_vtable v{};
+//   v.type = _SD_BUS_VTABLE_PROPERTY;
+//   v.flags = flags;
+//   v.x.property = decltype(v.x.property){member, signature, nullptr, nullptr, offset};
+
+//   return v;
+// }
+
+// constexpr sd_bus_vtable property_o(const char* member, const char* signature,
+//                                    sd_bus_property_set_t set, size_t offset,
+//                                    uint64_t flags)
+// {
+//   sd_bus_vtable v{};
+//   v.type = _SD_BUS_VTABLE_WRITABLE_PROPERTY;
+//   v.flags = flags;
+//   v.x.property = decltype(v.x.property){member, signature, nullptr, set, offset};
+
+//   return v;
+// }
+// } // namespace vtable
+// } // namespace sd_bus
+// } // namespace dbus
+// } // namespace anbox
+
+// #endif
diff --git a/src/anbox/dbus/skeleton/application_manager.cpp b/src/anbox/dbus/skeleton/application_manager.cpp
index f65902e..78d3293 100644
--- a/src/anbox/dbus/skeleton/application_manager.cpp
+++ b/src/anbox/dbus/skeleton/application_manager.cpp
@@ -25,148 +25,31 @@
 
 #include <core/property.h>
 
-namespace {
-int parse_string_from_message(sd_bus_message *m, std::string &str) {
-  const char *contents = nullptr;
-  auto r = sd_bus_message_enter_container(m, SD_BUS_TYPE_VARIANT, contents);
-  if (r < 0)
-    return r;
-
-  const char *value;
-  r = sd_bus_message_read(m, "s", &value);
-  if (r < 0)
-    return r;
-
-  str = value;
-
-  r = sd_bus_message_exit_container(m);
-  if (r < 0)
-    return r;
-
-  return 0;
-}
-} // namespace
-
 namespace anbox {
 namespace dbus {
 namespace skeleton {
-const sd_bus_vtable ApplicationManager::vtable[] = {
-  sdbus::vtable::start(0),
-  sdbus::vtable::method("Launch", "a{sv}s", "", ApplicationManager::method_launch, SD_BUS_VTABLE_UNPRIVILEGED),
-  sdbus::vtable::property("Ready", "b", ApplicationManager::property_ready_get, SD_BUS_VTABLE_PROPERTY_EMITS_CHANGE),
-  sdbus::vtable::end()
-};
-
-int ApplicationManager::method_launch(sd_bus_message *m, void *userdata, sd_bus_error *ret_error) {
-  auto r = sd_bus_message_enter_container(m, SD_BUS_TYPE_ARRAY, "{sv}");
-  if (r < 0)
-    return r;
-
-  android::Intent intent;
-
-  while ((r = sd_bus_message_enter_container(m, SD_BUS_TYPE_DICT_ENTRY, "sv")) > 0) {
-    const char *key = nullptr;
-
-    r = sd_bus_message_read(m, "s", &key);
-    if (r < 0)
-      return r;
-
-    if (strcmp(key, "package") == 0) {
-      r = parse_string_from_message(m, intent.package);
-      if (r < 0)
-        return r;
-    } else if (strcmp(key, "component") == 0) {
-      r = parse_string_from_message(m, intent.component);
-      if (r < 0)
-        return r;
-    } else if (strcmp(key, "action") == 0) {
-      r = parse_string_from_message(m, intent.action);
-      if (r < 0)
-        return r;
-    } else if (strcmp(key, "type") == 0) {
-      r = parse_string_from_message(m, intent.type);
-      if (r < 0)
-        return r;
-    } else if (strcmp(key, "uri") == 0) {
-      r = parse_string_from_message(m, intent.uri);
-      if (r < 0)
-        return r;
-    }
-
-    r = sd_bus_message_exit_container(m);
-    if (r < 0)
-      return r;
-  }
-
-  r = sd_bus_message_exit_container(m);
-  if (r < 0)
-    return r;
-
-  const char *stack = nullptr;
-  r = sd_bus_message_read(m, "s", &stack);
-  if (r <  0)
-    return r;
-
-  wm::Stack::Id launch_stack = wm::Stack::Id::Default;
-  if (stack && strlen(stack) > 0) {
-    auto s = std::string(stack);
-    std::istringstream i(s);
-    i >> launch_stack;
-  }
-
-  if (intent.package.length() == 0) {
-    sd_bus_error_set_const(ret_error, "org.anbox.InvalidArgument", "No package specified");
-    return -EINVAL;
-  }
-
-  auto thiz = static_cast<ApplicationManager*>(userdata);
-  try {
-    thiz->launch(intent, graphics::Rect::Invalid, launch_stack);
-  } catch (std::exception &err) {
-    ERROR("Failed to launch application: %s", err.what());
-    sd_bus_error_set_const(ret_error, "org.anbox.InternalError", err.what());
-    return -EIO;
-  }
-
-  return sd_bus_reply_method_return(m, "");
-}
-
-int ApplicationManager::property_ready_get(sd_bus *bus, const char *path, const char *interface,
-                                           const char *property, sd_bus_message *reply,
-                                           void *userdata, sd_bus_error *ret_error) {
-
-  (void) bus;
-  (void) path;
-  (void) interface;
-  (void) property;
-  (void) ret_error;
-
-  auto thiz = static_cast<ApplicationManager*>(userdata);
-
-  return sd_bus_message_append(reply, "b", thiz->impl_->ready().get());
-}
 
 ApplicationManager::ApplicationManager(const BusPtr& bus, const std::shared_ptr<anbox::application::Manager> &impl)
     : bus_(bus), impl_(impl) {
 
-  const auto r = sd_bus_add_object_vtable(bus_->raw(),
-                                          &obj_slot_,
-                                          interface::Service::path(),
-                                          interface::ApplicationManager::name(),
-                                          vtable,
-                                          this);
-  if (r < 0)
-    std::runtime_error("Failed to setup application manager DBus service");
-
-  impl_->ready().changed().connect([&](bool value) {
-    (void) value;
-
-    sd_bus_emit_properties_changed(bus_->raw(),
-                                   interface::Service::path(),
-                                   interface::ApplicationManager::name(),
-                                   interface::ApplicationManager::Properties::Ready::name(),
-                                   nullptr);
-  });
+  // const auto r = sd_bus_add_object_vtable(bus_->raw(),
+  //                                         &obj_slot_,
+  //                                         interface::Service::path(),
+  //                                         interface::ApplicationManager::name(),
+  //                                         vtable,
+  //                                         this);
+  // if (r < 0)
+  //   std::runtime_error("Failed to setup application manager DBus service");
+
+  // impl_->ready().changed().connect([&](bool value) {
+  //   (void) value;
+
+  //   sd_bus_emit_properties_changed(bus_->raw(),
+  //                                  interface::Service::path(),
+  //                                  interface::ApplicationManager::name(),
+  //                                  interface::ApplicationManager::Properties::Ready::name(),
+  //                                  nullptr);
+  // });
 }
 
 ApplicationManager::~ApplicationManager() {}
diff --git a/src/anbox/dbus/skeleton/application_manager.h b/src/anbox/dbus/skeleton/application_manager.h
index 68d3cee..dd0d12a 100644
--- a/src/anbox/dbus/skeleton/application_manager.h
+++ b/src/anbox/dbus/skeleton/application_manager.h
@@ -37,16 +37,9 @@ class ApplicationManager : public anbox::application::Manager {
 
   core::Property<bool>& ready() override;
 
- private:
-  static const sd_bus_vtable vtable[];
-  static int method_launch(sd_bus_message *m, void *userdata, sd_bus_error *ret_error);
-  static int property_ready_get(sd_bus *bus, const char *path, const char *interface,
-                                const char *property, sd_bus_message *reply, void *userdata,
-                                sd_bus_error *ret_error);
-
+ private:  
   BusPtr bus_;
-  std::shared_ptr<anbox::application::Manager> impl_;
-  sd_bus_slot *obj_slot_ = nullptr;
+  std::shared_ptr<anbox::application::Manager> impl_;  
 };
 }  // namespace skeleton
 }  // namespace dbus
diff --git a/src/anbox/dbus/skeleton/service.cpp b/src/anbox/dbus/skeleton/service.cpp
index 9d62d2d..0ace35a 100644
--- a/src/anbox/dbus/skeleton/service.cpp
+++ b/src/anbox/dbus/skeleton/service.cpp
@@ -32,9 +32,10 @@ Service::Service(const BusPtr& bus, const std::shared_ptr<anbox::application::Ma
   if (!bus_)
     throw std::invalid_argument("Missing bus object");
 
-  const auto r = sd_bus_request_name(bus_->raw(),
-                                     interface::Service::name(),
-                                     0);
+  const auto r = 1;
+  // const auto r = sd_bus_request_name(bus_->raw(),
+  //                                    interface::Service::name(),
+  //                                    0);
   if (r < 0)
     throw std::runtime_error("Failed to request DBus service name");
 
diff --git a/src/anbox/dbus/skeleton/service.h b/src/anbox/dbus/skeleton/service.h
index 4532a1b..de8cc3e 100644
--- a/src/anbox/dbus/skeleton/service.h
+++ b/src/anbox/dbus/skeleton/service.h
@@ -26,8 +26,6 @@
 #include <memory>
 #include <thread>
 
-#include <systemd/sd-bus.h>
-
 namespace anbox {
 namespace dbus {
 namespace skeleton {
diff --git a/src/anbox/dbus/stub/application_manager.cpp b/src/anbox/dbus/stub/application_manager.cpp
index 67153f3..ca18ea1 100644
--- a/src/anbox/dbus/stub/application_manager.cpp
+++ b/src/anbox/dbus/stub/application_manager.cpp
@@ -41,14 +41,15 @@ ApplicationManager::~ApplicationManager() {}
 
 void ApplicationManager::update_properties() {
   int ready = 0;
-  const auto r = sd_bus_get_property_trivial(bus_->raw(),
-                                             interface::Service::name(),
-                                             interface::Service::path(),
-                                             interface::ApplicationManager::name(),
-                                             interface::ApplicationManager::Properties::Ready::name(),
-                                             nullptr,
-                                             'b',
-                                             &ready);
+  const auto r = 1;
+  // const auto r = sd_bus_get_property_trivial(bus_->raw(),
+  //                                            interface::Service::name(),
+  //                                            interface::Service::path(),
+  //                                            interface::ApplicationManager::name(),
+  //                                            interface::ApplicationManager::Properties::Ready::name(),
+  //                                            nullptr,
+  //                                            'b',
+  //                                            &ready);
   if (r < 0)
     throw std::runtime_error("Failed to retrieve ready property from application manager");
 
@@ -60,72 +61,75 @@ void ApplicationManager::launch(const android::Intent &intent,
                                 const wm::Stack::Id &stack) {
   (void) launch_bounds;
 
-  sd_bus_message *m = nullptr;
-  auto r = sd_bus_message_new_method_call(bus_->raw(),
-                                          &m,
-                                          interface::Service::name(),
-                                          interface::Service::path(),
-                                          interface::ApplicationManager::name(),
-                                          interface::ApplicationManager::Methods::Launch::name());
+  DEBUG("Launching %s %08X", intent, stack);
+  
+  // sd_bus_message *m = nullptr;
+  auto r = 1;
+  // auto r = sd_bus_message_new_method_call(bus_->raw(),
+  //                                         &m,
+  //                                         interface::Service::name(),
+  //                                         interface::Service::path(),
+  //                                         interface::ApplicationManager::name(),
+  //                                         interface::ApplicationManager::Methods::Launch::name());
   if (r < 0)
     throw std::runtime_error("Failed to construct DBus message");
 
-  r = sd_bus_message_open_container(m, 'a', "{sv}");
-  if (r < 0)
-    throw std::runtime_error("Failed to construct DBus message");
-
-  if (intent.package.length() > 0) {
-    r = sd_bus_message_append(m, "{sv}", "package", "s", intent.package.c_str());
-    if (r < 0)
-      throw std::runtime_error("Failed to construct DBus message");
-  }
-
-  if (intent.component.length() > 0) {
-    r = sd_bus_message_append(m, "{sv}", "component", "s", intent.component.c_str());
-    if (r < 0)
-      throw std::runtime_error("Failed to construct DBus message");
-  }
-
-  if (intent.action.length() > 0) {
-    r = sd_bus_message_append(m, "{sv}", "action", "s", intent.action.c_str());
-    if (r < 0)
-      throw std::runtime_error("Failed to construct DBus message");
-  }
-
-  if (intent.type.length() > 0) {
-    r = sd_bus_message_append(m, "{sv}", "type", "s", intent.type.c_str());
-    if (r < 0)
-      throw std::runtime_error("Failed to construct DBus message");
-  }
-
-  if (intent.uri.length() > 0) {
-    r = sd_bus_message_append(m, "{sv}", "uri", "s", intent.uri.c_str());
-    if (r < 0)
-      throw std::runtime_error("Failed to construct DBus message");
-  }
-
-  r = sd_bus_message_close_container(m);
-  if (r < 0)
-    throw std::runtime_error("Failed to construct DBus message");
-
-  std::ostringstream launch_stack;
-  launch_stack << stack;
-  r = sd_bus_message_append(m, "s", launch_stack.str().c_str());
-  if (r < 0)
-    throw std::runtime_error("Failed to construct DBus message");
-
-  #pragma GCC diagnostic push
-  #pragma GCC diagnostic warning "-Wpragmas"
-  #pragma GCC diagnostic warning "-Wc99-extensions"
-  sd_bus_error error = SD_BUS_ERROR_NULL;
-  #pragma GCC diagnostic pop
-
-  r = sd_bus_call(bus_->raw(), m, 0, &error, nullptr);
-  if (r < 0) {
-    const auto msg = utils::string_format("%s", error.message);
-    sd_bus_error_free(&error);
-    throw std::runtime_error(msg);
-  }
+  // r = sd_bus_message_open_container(m, 'a', "{sv}");
+  // if (r < 0)
+  //   throw std::runtime_error("Failed to construct DBus message");
+
+  // if (intent.package.length() > 0) {
+  //   r = sd_bus_message_append(m, "{sv}", "package", "s", intent.package.c_str());
+  //   if (r < 0)
+  //     throw std::runtime_error("Failed to construct DBus message");
+  // }
+
+  // if (intent.component.length() > 0) {
+  //   r = sd_bus_message_append(m, "{sv}", "component", "s", intent.component.c_str());
+  //   if (r < 0)
+  //     throw std::runtime_error("Failed to construct DBus message");
+  // }
+
+  // if (intent.action.length() > 0) {
+  //   r = sd_bus_message_append(m, "{sv}", "action", "s", intent.action.c_str());
+  //   if (r < 0)
+  //     throw std::runtime_error("Failed to construct DBus message");
+  // }
+
+  // if (intent.type.length() > 0) {
+  //   r = sd_bus_message_append(m, "{sv}", "type", "s", intent.type.c_str());
+  //   if (r < 0)
+  //     throw std::runtime_error("Failed to construct DBus message");
+  // }
+
+  // if (intent.uri.length() > 0) {
+  //   r = sd_bus_message_append(m, "{sv}", "uri", "s", intent.uri.c_str());
+  //   if (r < 0)
+  //     throw std::runtime_error("Failed to construct DBus message");
+  // }
+
+  // r = sd_bus_message_close_container(m);
+  // if (r < 0)
+  //   throw std::runtime_error("Failed to construct DBus message");
+
+  // std::ostringstream launch_stack;
+  // launch_stack << stack;
+  // r = sd_bus_message_append(m, "s", launch_stack.str().c_str());
+  // if (r < 0)
+  //   throw std::runtime_error("Failed to construct DBus message");
+
+  // #pragma GCC diagnostic push
+  // #pragma GCC diagnostic warning "-Wpragmas"
+  // #pragma GCC diagnostic warning "-Wc99-extensions"
+  // sd_bus_error error = SD_BUS_ERROR_NULL;
+  // #pragma GCC diagnostic pop
+
+  // r = sd_bus_call(bus_->raw(), m, 0, &error, nullptr);
+  // if (r < 0) {
+  //   const auto msg = utils::string_format("%s", error.message);
+  //   sd_bus_error_free(&error);
+  //   throw std::runtime_error(msg);
+  // }
 }
 
 core::Property<bool>& ApplicationManager::ready() {
